/*1. Напишите запрос с временной таблицей и перепишите его с табличной переменной. Сравните планы.
В качестве запроса с временной таблицей и табличной переменной можно взять свой запрос или следующий запрос:
Сделать расчет суммы продаж нарастающим итогом по месяцам с 2015 года (в рамках одного месяца он будет одинаковый, нарастать будет в течение времени выборки)
Выведите id продажи, название клиента, дату продажи, сумму продажи, сумму нарастающим итогом
Пример
Дата продажи Нарастающий итог по месяцу
2015-01-29 4801725.31
2015-01-30 4801725.31
2015-01-31 4801725.31
2015-02-01 9626342.98
2015-02-02 9626342.98
2015-02-03 9626342.98
Продажи можно взять из таблицы Invoices.
Нарастающий итог должен быть без оконной функции.*/

with cte_montsum
as (
select	sum(sil.ExtendedPrice) as monthsum
		,month(si.InvoiceDate) as monthdate
from Sales.InvoiceLines as sil
join Sales.Invoices as si on sil.ExtendedPrice=si.InvoiceID
group by month(si.InvoiceDate))

select
i.InvoiceID,
c.CustomerName,
i.InvoiceDate,
il.ExtendedPrice,
(select sum(ct.monthsum) from cte_montsum as ct
where ct.monthdate<=month(i.InvoiceDate) )
from Sales.Invoices as i
join Sales.InvoiceLines as il on i.InvoiceID=il.InvoiceID
join Sales.Customers as c on c.CustomerID=i.CustomerID
where year(i.InvoiceDate)>=2015
order by  c.CustomerName, i.InvoiceDate asc
---------------------------------------------------------------------------
/*2. Если вы брали предложенный выше запрос, то сделайте расчет суммы нарастающим итогом с помощью оконной функции.
Сравните 2 варианта запроса - через windows function и без них. Написать какой быстрее выполняется, сравнить по set statistics time on;*/
select i.InvoiceID, c.CustomerName, i.InvoiceDate, il.ExtendedPrice,
	SUM(il.ExtendedPrice) OVER (PARTITION BY month(i.InvoiceDate)) as totalmonth
from Sales.Invoices as i
join Sales.InvoiceLines as il on i.InvoiceID=il.InvoiceID
join Sales.Customers as c on c.CustomerID=i.CustomerID
where year(i.InvoiceDate)>=2015
order by  i.InvoiceDate asc


/*3. Вывести список 2х самых популярных продуктов (по кол-ву проданных) в каждом месяце за 2016й год (по 2 самых популярных продукта в каждом месяце)*/
select*from(
			select	s.StockItemName, month(o.OrderDate),
				row_number() OVER (partition by month(OrderDate) order by ol.Quantity desc) AS topmonth
			from Sales.Orders as o
			join Sales.OrderLines as ol on o.OrderID=ol.OrderID
			join Warehouse.StockItems as s on ol.StockItemID=s.StockItemID
			where year(o.OrderDate)=2016)
where topmonth <= 2;
------------------------------------------------
select top(2) with ties 
s.StockItemName, month(o.OrderDate),row_number() OVER (partition by month(OrderDate) order by ol.Quantity desc)
from Sales.Orders as o
				join Sales.OrderLines as ol on o.OrderID=ol.OrderID
				join Warehouse.StockItems as s on ol.StockItemID=s.StockItemID
				where year(o.OrderDate)=2016
order by row_number() OVER (partition by month(OrderDate) order by ol.Quantity desc)


/*4. Функции одним запросом
Посчитайте по таблице товаров, в вывод также должен попасть ид товара, название, брэнд и цена
пронумеруйте записи по названию товара, так чтобы при изменении буквы алфавита нумерация начиналась заново
посчитайте общее количество товаров и выведете полем в этом же запросе
посчитайте общее количество товаров в зависимости от первой буквы названия товара
отобразите следующий id товара исходя из того, что порядок отображения товаров по имени
предыдущий ид товара с тем же порядком отображения (по имени)
названия товара 2 строки назад, в случае если предыдущей строки нет нужно вывести "No items"
сформируйте 30 групп товаров по полю вес товара на 1 шт
Для этой задачи НЕ нужно писать аналог без аналитических функций*/


/*5. По каждому сотруднику выведите последнего клиента, которому сотрудник что-то продал
В результатах должны быть ид и фамилия сотрудника, ид и название клиента, дата продажи, сумму сделки*/


/*6. Выберите по каждому клиенту 2 самых дорогих товара, которые он покупал
В результатах должно быть ид клиета, его название, ид товара, цена, дата покупки*/